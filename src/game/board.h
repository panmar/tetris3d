#ifndef TETRIS3D_GAME_BOARD_H_
#define TETRIS3D_GAME_BOARD_H_

#include <vector>

#include "glm/vec3.hpp"

namespace tetris3d {

class Board {
public:
    Board(int width, int depth, int height);

    int GetWidth() const { return width_; }
    int GetDepth() const { return depth_; }
    int GetHeight() const { return height_; }
    const std::vector<unsigned>& GetCells() const { return cells_; }
    unsigned GetCell(size_t index) const { return cells_[index]; }

    void Fill(const glm::ivec3& position, unsigned value);
    bool IsEmpty(const glm::ivec3& position) const;
    bool Contains(const glm::ivec3& position) const;
    size_t PositionToIndex(const glm::vec3& world_pos) const;

    // Return number of filled layers erased; if there are no filled layers
    // return zero
    unsigned EraseFilledLayers();

    void EraseLayer(unsigned layer);

    // 'layer' is height index of the board (counting from ground (0-based))
    bool IsLayerFilled(unsigned layer) const;

private:
    const int width_ = 0;
    const int depth_ = 0;
    const int height_ = 0;

    // NOTE(panmar): If zero cell is empty, otherwise is taken
    // If it is taken value store indicates a color for this particular cell
    // Color is packed as 32-bit: 0x00RRGGBB, leaving 8 bit for each channel
    // ----
    // 0        - empty
    // non-zero - taken (packed color)
    // ----
    // TODO(panmar): Change this scheme; Maybe we could store autogenerated
    // id here and move chosing colors to renderer? In that way even pure
    // black color could be taken if needed and game colorscheme could be
    // changed easily
    std::vector<unsigned> cells_;
};

} // namespace tetris3d

#endif // TETRIS3D_GAME_BOARD_H_
